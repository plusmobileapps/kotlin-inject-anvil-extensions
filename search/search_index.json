{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Kotlin Inject Anvil Extensions","text":"<p>A collection of extensions on top of kotlin-inject-anvil to help reduce boiler plate with dependency injection. </p>"},{"location":"#extensions","title":"Extensions","text":"<ul> <li>Assisted factory - bind factory interfaces to dependencies using the <code>@Assisted</code> annotation.</li> </ul>"},{"location":"#setup","title":"Setup","text":"<p>Before using any of the anvil extensions, setup your project per the instructions from kotlin-inject and kotlin-inject-anvil. </p>"},{"location":"assisted-factory/","title":"Assisted Factory Extension","text":"<p>An extension to help bind factory interfaces in anvil when using assisted injection from kotlin-inject. </p>"},{"location":"assisted-factory/#setup","title":"Setup","text":"<p>The library is available through maven central, so include this in your repositories of your <code>settings.gradle.kts</code>. </p> <pre><code>pluginManagement {\n    repositories {\n        gradlePluginPortal()\n        mavenCentral()\n    }\n}\n</code></pre> <ul> <li>compiler - </li> <li>runtime - </li> </ul> <p>When using version catalogs, add the following version and library modules.</p> <pre><code>[versions]\nkotlinInjectAnvilExtensions = \"{version}\"\n\n[libraries]\nkotlinInjectAnvilExtensions-assistedFactory-compiler = { module = \"com.plusmobileapps.kotlin-inject-anvil-extensions:assisted-factory-compiler\", version.ref = \"kotlinInjectAnvilExtensions\" }\nkotlinInjectAnvilExtensions-assistedFactory-runtime = { module = \"com.plusmobileapps.kotlin-inject-anvil-extensions:assisted-factory-runtime\", version.ref = \"kotlinInjectAnvilExtensions\" }\n</code></pre> <p>Then in the <code>build.gradle.kts</code> configure ksp with the libraries.</p> <pre><code>dependencies {\n    // update with your app's targets.\n    val targets = listOf(\n        \"kspAndroid\",\n        \"kspIosX64\",\n        \"kspIosArm64\",\n        \"kspIosSimulatorArm64\"\n    )\n    commonMainImplementation(libs.kotlinInjectAnvilExtensions.assistedFactory.runtime)\n    targets.forEach {\n        add(it, libs.kotlinInjectAnvilExtensions.assistedFactory.compiler)\n    }\n}\n</code></pre>"},{"location":"assisted-factory/#why-assisted-factory","title":"Why Assisted Factory?","text":"<p>The current APIs between kotlin-inject and kotlin-inject-anvil do allow you to use assisted injection, however to bind a factory interface in your dependency graph to generate an assisted dependency can require a bit of boiler plate. For this example let's assume the following dependency: </p> <pre><code>interface MovieRepository {\n    fun get(): Movie\n}\n\n@Inject\n@ContributesBinding(AppScope::class)\n@SingleIn(AppScope::class)\nclass RealMovieRepository(@Assisted val id: String) : MovieRepository {\n    override fun get(): Moview = TODO()\n}\n</code></pre> <p>The above code will bind a factory method <code>(String) -&gt; RealMovieRepository</code> that can be injected in any other dependency. Although for testing purposes, it would be better if the factory method bound was returning the interface instead like <code>(String) -&gt; MovieRepository</code>. An even better solution would be to create a strongly typed interface and bind that to the real factory method, however this requires some boiler plate creating a real factory that injects the real factory and implementing the factory interface.</p> <pre><code>interface MovieRepository {\n    interface Factory {\n        fun create(id: String): MovieRepository\n    }\n}\n\n@Inject\n@ContributesBinding(AppScope::class)\n@SingleIn(AppScope::class)\nclass RealMovieRepositoryFactory(\n    val realFactory: (String) -&gt; RealMovieRepository,\n) : MovieRepository.Factory {\n\n    override fun create(id: String): MovieRepository = realFactory(id)\n}\n</code></pre> <p>This is where the assisted factory extension comes in by implementing that boiler plate for you removing the need to implement a real factory binding. </p>"},{"location":"assisted-factory/#usage","title":"Usage","text":"<p>To use the assisted factory anvil extension, all that is needed is to annotate the dependency with the <code>@ContributesAssistedFactory</code> annotation.</p> <pre><code>interface MovieRepository {\n    fun get(): Movie\n\n    interface Factory {\n        fun create(id: String): MovieRepository\n    }\n}\n\n@Inject\n@ContributesAssistedFactory(\n    scope = AppScope::class,\n    assistedFactory = MovieRepository.Factory::class,\n)\nclass RealMovieRepository(\n    @Assisted val id: String,\n) : MovieRepository {\n    override fun get(): Movie = TODO()\n}\n</code></pre> <p>The above code will generate a real factory and bind the factory interface in the dependency graph for you. Then you can simply inject that factory into any other class.</p> <pre><code>@Inject\nclass MovieDetailViewModel(\n    private val factory: MovieRepository.Factory\n) {\n    fun create(id: String) {\n        val repository: MovieRepository = factory.create(id)\n    }\n}\n</code></pre>"}]}